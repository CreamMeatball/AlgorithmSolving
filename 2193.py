N = int(input())

dp = [[0] * 2 for _ in range(N + 1)]
dp[1][0] = 0 # 1자리수 + 0으로 끝나는 이친수 개수
dp[1][1] = 1 # 1자리수 + 1로 끝나는 이친수 개수

if N >= 2: # 안 해주면 IndexError 발생 (N = 1일 경우)
    for i in range(2, N + 1):
        dp[i][0] = dp[i - 1][0] + dp[i - 1][1]
        dp[i][1] = dp[i - 1][0]
    
# for d in dp[1:]:
#     print(d)
    
print(dp[N][0] + dp[N][1])


# for d in dp[1:]:
#     print(sum(d), end=', ')
# print()

# 이게 (위 코드로) 확인해보니까
# 피보차니 수열이랑 똑같음.
# 그래서 아래 1차원 DP로도 풀 수 있음.

# dp = [0] * (N + 1)
# dp[1] = 1

# if N >= 2:
#     for i in range(2, N + 1):
#         dp[i] = dp[i - 1] + dp[i - 2]

# print(dp[N])


# [피보나치 수열이랑 같은 이유] (by Gemini)

# 이유를 한 문장으로 요약하면, 새로운 N번째 자리의 숫자를 결정하는 규칙이 그 이전 상태(N−1)와 그 이전 상태(N−2)의 총합으로만 정의되기 때문입니다.
# 조금 더 자세히 설명해 드릴게요.
# 우리가 구하려는 것을 D[N] ( N자리 이친수의 총 개수)이라고 정의해 보겠습니다.
# N자리 이친수를 만들려면, $(N-1)$자리 이친수의 뒤에 '0'이나 '1'을 덧붙여야 합니다. 이 과정에서 규칙을 만족시키는 경우만 세어보면 됩니다.
# N자리 이친수는 마지막 숫자가 '0'이거나 '1'인 두 가지 경우밖에 없습니다.

# Case 1: N자리 이친수가 '0'으로 끝나는 경우
# (N-1 자리 이친수)+ ′0′
# $(N-1)$자리 이친수가 무엇으로 끝나든('0'이든 '1'이든) 그 뒤에 '0'을 붙이는 것은 '11' 규칙을 절대로 위반하지 않습니다. ( ...0 + 0 → "00" / ...1 + 0 → "10". 둘 다 괜찮음)
# 따라서 '0'으로 끝나는 N자리 이친수의 개수는, (N-1)자리 이친수의 모든(총) 개수와 정확히 같습니다.
# 수식으로 표현하면: ( N자리 중 0으로 끝나는 개수 ) = D[N−1]

# Case 2: N자리 이친수가 '1'로 끝나는 경우
# (N-1 자리 이친수)+ ′1′
# '1'을 붙이려면 "11" 규칙을 피해야 합니다. 이 말은 $(N-1)$자리 이친수가 절대로 '1'로 끝나서는 안 되고, 반드시 '0'으로 끝나야 한다는 뜻입니다.
# 따라서 '1'로 끝나는 N자리 이친수의 개수는, (N-1)자리 이친수 중 '0'으로 끝나는 것들의 개수와 정확히 같습니다.
# 수식으로 표현하면: ( N자리 중 1로 끝나는 개수 ) = ( $(N-1)$자리 중 0으로 끝나는 개수 )

# D[N] (N자리 총 개수) = ( N자리 중 0으로 끝나는 개수 ) + ( N자리 중 1로 끝나는 개수 )
# 위에서 구한 Case 1, 2의 결론을 이 식에 대입하면:
# D[N] = ( '0'으로 끝나는 경우 ) + ( '1'로 끝나는 경우 )
# D[N] = ( D[N−1] ) + ( $(N-1)$자리 중 0으로 끝나는 개수 )

# $(N-1)$자리 중 0으로 끝나는 개수 가 무엇인지 알아내야 합니다.
# 이때, Case 1에서 얻은 결론을 그대로 다시 사용하면 됩니다.
# Case 1의 결론: i자리 이친수 중 '0'으로 끝나는 개수 = $(i-1)$자리 이친수의 총 개수 (D[i−1])
# 위 결론(규칙)에 i 대신 $(N-1)$을 대입해 봅시다.
# ( $(N-1)$자리 중 0으로 끝나는 개수 ) = ( $(N-2)$자리 이친수의 총 개수 ) = D[N−2]
# 자, 이제 이 결과를 아까의 D[N] 식에 최종적으로 대입합니다.
# D[N] = ( D[N−1] ) + ( D[N−2] )