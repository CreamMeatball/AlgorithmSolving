import sys

input = sys.stdin.readline

T = int(input().rstrip())

# 당연하게도, 주어진 N이 처음부터 완전제곱수면, 구사과가 이길거고,
# 그렇지 않은 경우엔, 비완전제곱수에서 어떤 수를 뺄 때,
# 어떻게 빼도 완전제곱수로 변한다면 구사과가 이길 거고,
# 그렇지 않다면 또 따져봐야됨.
# 이런 식으로 반복.

# 결국,
# 1) 가능한 모든 x에 대해 N - x 가 어떤 경우에도 승리하는 경우라면, 나는 패배함.
# 2) 가능한 모든 x에 대해 N - x 중 단 하나라도 패배하는 수가 된다면, 나는 승리함.

dp = [False] * (10 ** 6 + 1)

# 처음부터 제곱수일 경우 구사과가 이김.
for i in range(1, 10 ** 3 + 1):
    dp[i * i] = True

# 위에서 서술한 2) 에 의거,
# 내가 어떤 수 x를 뺐을 때 N - x 가 패배 수가 되는 경우가 단 하나라도 있다면, 나는 승리한다.
# -> 그렇기에, 어떠한 패배하는 수 y에 제곱수가 더해진 수는 내가 승리하는 수임. 제곱수를 빼서 y로 만들어버리면 되니.
for i in range(2, 10 ** 6 + 1):
    if not dp[i]: # i라는 숫자를 받았을 때, 패배하는 숫자인 경우.
        # 패배하는 숫자 i에다가 모든 완전제곱수 더한 숫자 경우를 탐색.
        for j in range(1, 10 ** 3 + 1):
            squared = j * j
            if i + squared > 10 ** 6:
                break
            dp[i + squared] = True # 이기는 경우임을 명시.
            # 왜냐면,
            # 어떠한 완전 제곱수를 뺐을 때, N - x가 패배하는 숫자가 되는 경우가 단 한 경우라도 있다면
            # 최적의 플레이를 하기 때문에 분명 그 x로 뺄 거고, 상대는 패배하게 될 거임. 나는 승리하고.
            # 그렇기에 '패배하는수' + '제곱수' 의 경우, 무조건 이김.

for _ in range(T):
    N = int(input().rstrip())
    if dp[N]:
        print('koosaga')
    else:
        print('cubelover')