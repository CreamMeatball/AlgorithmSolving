N = int(input())

# 15의 배수이기 위한 (효율적) 조건
# 15의 배수이려면, 3의 배수이면서 5의 배수여야 함.
# 이에 이어,
# 3의 배수려면, 모든 자릿수의 합이 3의 배수여야 함
# 5의 배수려면, 마지막 자릿수가 0 또는 5여야 함. -> 문제에서는 1 or 5니까, 마지막 자릿수가 5여야 함.

# -> 문제에서 15의 배수려면:
# 모든 자릿수의 합이 3의 배수면서, 마지막 자릿수가 5여야 함.

# 추가적으로, dp를 통해 자릿수의 합이 3이 배수임을 검증할 때,
# 전체 다 합해서 할 필요 없이,
# 이전 숫자에서, 3으로 나눈 나머지가 2였디면,
# 이전숫자 * 10 도 3으로 나누면 나머지가 2임.
# 그래서 "(이전숫자를 3으로 나눈 나머지) + (이번에 이어붙일 숫자) % 3" = "전체 숫자 % 3" 임.
# 그렇기에 이전 숫자를 3으로 나눈 나머지 값만 기억해뒀다가,
# (이전 나머지값 + 이번 숫자) % 3 하면 검증 됨.

# 

dp = [[[0] * 2 for _ in range(3)] for _ in range(N + 1)]

# dp[i]: 숫자 길이
# dp[i][j]: 3으로 나눴을 때 나머지가 0/1/2 가 나올 때의 개수
# dp[i][j][k]: 마지막 숫자가 1/5 인 숫자의 개수

MOD = 1_000_000_007
dp[1][1][0] = 1
dp[1][2][1] = 1

for i in range(2, N + 1):
    for j in range(3):
        prev_j_for_1 = (j - 1) % 3 # 이번에 1을 뒤에 붙이니까, 위에 말한 나머지 원리에 의해, 1을 붙였을 떄 나머지가 0이 되게끔 하기 위해
        dp[i][j][0] = (dp[i-1][prev_j_for_1][0] + dp[i-1][prev_j_for_1][1]) % MOD # 3으로 나눈 나머지가 0이 되면서, 끝자리가 1인 숫자의 개수
        prev_j_for_5 = (j - 2) % 3 # 이번에 5를 뒤에 붙이니까, 위에 말한 나머지 원리에 의해, 5를 붙였을 떄 나머지가 0이 되게끔 하기 위해
        dp[i][j][1] = (dp[i-1][prev_j_for_5][0] + dp[i-1][prev_j_for_5][1]) % MOD # 3으로 나눈 나머지가 0이 되면서, 끝자리가 5인 숫자의 개수

# for d in dp[1:]:
#     print(*d)

print(dp[N][0][1]) # 끝자리가 5로 끝나는 경우만.